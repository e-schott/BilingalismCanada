---
title: "Census Bilingualism Analysis"
output:
  html_document:
    df_print: paged
---
author: Esther Schott
please email esther.schott@mail.concordia.ca if you have any questions
see poster created from this script: https://osf.io/4gekn/

# 1. Preparation Steps
## Script settings
```{r}
load_data_from_raw = FALSE # If true, loads data from .sav, else loads R file (faster)
use_reduced_data_set = TRUE # If true, uses a smaller subset of full data set (for troubleshooting etc.)
```

## load packages
```{r echo=FALSE}
library(here)
library(tidyverse)
library(rio) # for reading in SPSS files
library(labelled)
library(cowplot)
library(viridis)
library(janitor)

library(codebook)

# for map stuff
#library(rworldmap)
#library(ggmap)
#library(rgdal)
#library(maps)
library(scales)
# for circle plots
# install.packages("packcircles")
#library(packcircles)
```

## function necessary to read in spss
see https://dadoseteorias.wordpress.com/2017/04/29/read-spss-duplicated-levels/
for more info
```{r}
Int2Factor <- function(x)
{
    if(!is.null(attr(x, "value.labels"))){
        vlab <- attr(x, "value.labels")
        if(sum(duplicated(vlab)) > 0)
            cat("Duplicated levels:", vlab, "\n")
        else if(sum(duplicated(names(vlab))) > 0)
            cat("Duplicated labels:",
                names(vlab)[duplicated(names(vlab))], "\n")
        else
            x <- factor(x, levels = as.numeric(vlab),
                        labels = names(vlab))
    }
    x
}


```


# INDIVIDUALS dataset

###  read in invididuals file

```{r}




# 2016 data files
if(load_data_from_raw == TRUE) {
raw_idata = import(here("01_datasets/pumf-98M0001-E-2016-individuals_F1.sav"), 
                      format = "sav")
saveRDS(raw_idata, here("03_output/00_processed_data/idata_raw.Rdata"))} else {
raw_idata =   readRDS(here("03_output/00_processed_data/idata_raw.Rdata"))
}


# convert strings to factors 
idata <- lapply(raw_idata, 
                    Int2Factor)
# convert list to dataframe
idata <- as.data.frame(idata, 
                           stringsAsFactors = FALSE)

# select which variables are necessary for our analysis
variables.keep = c("PPSORT", # individual case ID
  "PR","CMA", # location: province & metropolitain area
                   "AGEGRP","PKID0_1", "PKID2_5", # number of children between 0 and 1, and 2 and 5
                   "HLAEN","HLAFR","HLANO", # home language part A
                   "HLBEN","HLBFR","HLBNO", #home language part B
                    "CFInc", "DPGRSUM")
idata_short = idata %>% select(variables.keep)
idata_short$Child0_1 = factor(idata_short$PKID0_1, labels=c("NotAvailable","1+","0"))
idata_short$Child2_5 = factor(idata_short$PKID2_5, labels=c("NotAvailable","1+","0"))

# create age_bracket variable... 
idata_short$age_bracket = ifelse(as.integer(idata_short$AGEGRP)<16, "adult","child")

idata_short = idata_short %>%
  rename(caseID = "PPSORT")


```
## use subset of full data (for troubleshooting)
```{r}
if(use_reduced_data_set == TRUE) {
  idata_short = idata_short %>%
    sample_n(50000)
}
```


###  change factor levels & variable names for language variables
this needs to be cleaned up & shortened (Esther)
```{r}



# change factor levels for question part a ("language used most often")
idata_short$HLA_En = factor(idata_short$HLAEN, labels= c(NA,T,F))
levels(idata_short$HLA_En) <- list(NotAvailable = NA,English = "TRUE",N="FALSE")
levels(idata_short$HLA_En)[levels(idata_short$HLA_En)=='NotAvailable'] <- NA


idata_short$HLA_Fr = factor(idata_short$HLAFR, labels= c(NA,T,F))
levels(idata_short$HLA_Fr) <- list(NotAvailable =NA, French = "TRUE",N="FALSE")
levels(idata_short$HLA_Fr)[levels(idata_short$HLA_Fr)=='NotAvailable'] <- NA


idata_short$HLA_Oth = factor(idata_short$HLANO)
levels(idata_short$HLA_Oth)[levels(idata_short$HLA_Oth)=='No non-official language'] <- "N"
levels(idata_short$HLA_Oth)[levels(idata_short$HLA_Oth)== 'Not available'] <- NA

levels(idata_short$HLA_Oth)[levels(idata_short$HLA_Oth)=='All other languages'] <- "Other"

# change for question part b (regular use)
idata_short$HLB_En = factor(idata_short$HLBEN, labels= c(NA, T,F))
levels(idata_short$HLB_En) <- list(NotAvailable =NA, English = "TRUE",N="FALSE")
levels(idata_short$HLB_En)[levels(idata_short$HLB_En)=='NotAvailable'] <- NA

idata_short$HLB_Fr = factor(idata_short$HLBFR, labels= c(NA,T,F))
levels(idata_short$HLB_Fr) <- list(NotAvailable =NA, French = "TRUE",N="FALSE")
levels(idata_short$HLB_Fr)[levels(idata_short$HLB_Fr)=='NotAvailable'] <- NA


idata_short$HLB_Oth = factor(idata_short$HLBNO, labels = c(T, F))
levels(idata_short$HLB_Oth) <- list(Other = "TRUE",N="FALSE")
#levels(idata_short$HLB_Oth)[levels(idata_short$HLB_Oth)=='N'] <- NA


```

### convert from wide to long
For easier counting of languages etc.
```{r}
old_language_cols = c("HLAEN","HLAFR", "HLANO","HLBEN",  "HLBFR", "HLBNO" )
idata_long = idata_short %>% 
  select(-old_language_cols) %>%
  # cut down size of df for debugging
  #sample_n(193000) %>%

  gather(lang_question, answer,HLA_En:HLB_Oth) %>%
  arrange(caseID)


```

#### create bilingualism variable (wide df)
```{r}
idata_long = idata_long %>%
 mutate(language_reported = if_else(answer =="N",0,1)) %>%
  group_by(caseID) %>%
  mutate(N_Lang = sum(language_reported, na.rm=T),
         N_Two_or_more = case_when(
                                  N_Lang == 1 ~ "1",
                                  N_Lang >1 ~ "2+",
                                  is.na(N_Lang) ~ NA_character_),
        # Lang_Combo_ranked = paste(answer[language_reported==1], 
        #                           collapse ="_"),
        # Lang_Combo_a_z = paste(sort(answer[language_reported==1]), 
        #                        collapse ="_"),
         Lang_Combo_top2 = paste(sort(answer[language_reported==1][1:2]), 
                                 collapse ="_")) 

idata_long = idata_long %>% ungroup()
# idata_long %>% filter(N_Lang>1) %>% View()

```

#### get back to wide (one-case-one-row)
```{r}
idata_wide = idata_long %>% select(-lang_question, -answer, -language_reported) %>%
  distinct()
```



### create variable for geographical locations of interest
```{r}
idata_long$gma.interest = ifelse(idata_long$CMA %in% c("Vancouver", "Montréal", "Toronto","Ottawa - Gatineau" , "Calgary", "Edmonton"),as.character(idata_long$CMA), NA)
```


 

## keep only children 0-4, save idata_child for creating map


```{r}

idata_child = idata_wide %>%
  filter(AGEGRP == "0 to 4 years")
saveRDS(idata_child, file = here::here("03_output","00_processed_data", "Individuals_child_data.rdata"))

  
#gma_LangGroup_data = gma_LangGroup_data %>% 
#  mutate(Area = agrep()

```




#  Individuals dataset: descriptives
### summary tables: children across canada
check how distributions over province and metropolitain areas are
```{r}
# select only adults who are living with at least one child
idata_hh_child = idata_wide %>% 
  filter(PKID0_1 =="One or more" | PKID2_5 =="One or more") %>% 
  filter(age_bracket=="adult")

# how many are there per province & area?
idata_hh_child %>% group_by(PR, CMA) %>%
  summarize(N=n()) %>% 
  spread(PR, N)

# breakdown by province
idata_child %>% group_by(PR) %>%
  summarize(N=n())

# some provinces have  few data points. can probably concentrate on BC, Alberta, Ontario, Quebec



# top metropolitain areas
idata_child %>% group_by(CMA) %>%
   summarize(N=n()) %>%
  arrange(-N)
# top metropolitain areas are: Toronto, Montréal, Vancouver Calgary, Ottawa - Gatineau, Edmonton (cutoff could be 5000 individuals?)

```
## bilingualism in children in individuals dataset
#### summary table: bilingual children across canada

```{r}
# commented out because I need to fix langGroup
# idata_short %>% filter(age_bracket == "child") %>%
#   group_by(AGEGRP, LangGroup_individual) %>%
#   summarize(N=n()) %>%
#   spread(LangGroup_individual, N) %>%
#   clean_names() %>%
#   mutate(total = one_language+two_or_more, percent = two_or_more/total)


```

#### summary tables: bilingual children under 6yo by province & metropolitan area
```{r}
# commented out because I need to fix langGroup

# idata_short %>% filter(AGEGRP == "0 to 4 years"| AGEGRP =="5 to 6 years") %>%
#   group_by(gma.interest, LangGroup_individual) %>%
#   summarize(N=n()) %>%
#   spread(LangGroup_individual, N) %>%
#   clean_names() %>%
#   mutate(total = one_language+two_or_more, percent = round(two_or_more/total,3)) 

```


#### summary tables: number of bilingual adults living with a child under 5

```{r}
# commented out because I need to fix langGroup

# 
# idata_child %>%
#   filter(Child0_1 == "1+"  ) %>%
#   group_by(LangGroup_individual) %>%
#   summarize(Count = n())%>%
#   mutate(           Percent = Count/sum(Count))
# 
# # broken down by key metropolotain areas
# 
# idata_child %>%
#   filter(!is.na(gma.interest)& Child0_1 == "1+" |Child2_5=="1+") %>%
#   group_by( gma.interest, LangGroup_individual) %>%
#   summarize(Count = n())%>%
#   mutate(           Percent = Count/sum(Count)) 
#   
# 
# 
# # need to investigate what to do with these NA in other language
# idata_child %>% filter(is.na(LangGroup)) %>% 
#   group_by(LangPair_simplified) %>% 
#   summarize(count=n())
# 
# # look at 2-5 year olds
# idata_child %>% 
#   filter(Child2_5 == "1+") %>%
#   group_by(LangGroupBil) %>%
#   summarize(Count = n())  %>%
#   mutate(           Percent = Count/sum(Count))

# these look relatively the same as the one-year olds, focus on the one-year olds becuase they are our population of interest and 2-5 year olds likely get more exposure outside of the house (not captured in this survey)
```


#  HOUSEHOLDS dataset

## To Dos:
- Total income still has SPSS style missing values (9999999), need to replace with NA and see if that is the case for others too
- need to clean up HLANO (remove  language names in parentheses, make labels less wordy...)
```{r}

```


## read in dataset 
```{r}
# need to change to reading in factor solution as above
if(load_data_from_raw == TRUE) {
  raw_hhdata = rio::import(here("01_datasets/Census-98M0002X-E-2016-Hierarchial_F1.sav"),format = "sav")
  saveRDS(raw_hhdata, here("03_output/00_processed_data/hdata_raw.Rdata"))} else {
  raw_hhdata = readRDS(here("03_output/00_processed_data/hdata_raw.Rdata"))
}

  






```
## data cleaning - general
### convert to categorical variables to factors to see variable labels
```{r}
# make factor - the spss variable has all variables stored as numeric, which makes them read into R as numeric (which means it doesn't show labels present in the dataset). Can use factorize to remedy that: 

# the columns I keep here were just a selection  made quickly, see user guide to see others potentially interesting
columns_to_convert_to_factor = c("PR","CMA", "AGEGRP", "SEX", "SSGRAD", 
                                 # place of birth:
                                 "POB", "POBF", "POBM",
                                 # native language:
                                 "MTNEn", "MTNFr", "MTNNO",
                                 #home language (most often)
                         "HLAEN", "HLAFR", "HLANO", 
                         # home language (regularly)
                         "HLBEN", "HLBFR", "HLBNO", 
                         # immigration, income, etc.
                         "YRIMM", "VISMIN", "IMMSTAT", "CITIZEN")

# batch convert to factor
raw_hhdata = raw_hhdata %>%
  mutate_at(.vars = vars(columns_to_convert_to_factor),
             .funs = factorize)
# now, instead of numbers e.g. for provice we see the actual label in the df
```


### select variables of interest
```{r}
# select which variables are necessary for our analysis
# keep all that we've converted to factor, and Household and person id, which are numeric so didn't need to convert to factor
variables.hkeep = c("HH_ID","PP_ID", "TOTINC_AT",
  columns_to_convert_to_factor) #home language part B
hhdata = raw_hhdata %>% select(variables.hkeep)
```


### create variable for households with children 9 and under

```{r}
# create a variable that says whether child younger than 10 lives in household


hhdata = hhdata %>% 
  mutate(child0_9 = ifelse(AGEGRP == "0 to 9 years", 1,0)) %>%
    group_by(HH_ID) %>%
  mutate(number_of_children0_9 = sum(child0_9))



```

### use subset of full data (for troubleshooting)
This is necessary while creating the code because some code is SLOW. change use_reduced_data_set to change at the top of the script
```{r}

if(use_reduced_data_set == TRUE) {
  # select X unique households to keep in subset
  household_subsample = sample(unique(hhdata$HH_ID),
                               20000)  
  hhdata = hhdata %>%
    filter(HH_ID %in% household_subsample)
}

```




## data cleaning -   language variables
```{r}

#make this simpler


hhdata = hhdata %>%
  mutate_at( .vars = vars(HLAEN, HLAFR, HLBEN, HLBFR, HLBNO),
             ~ fct_relabel(., ~str_remove(., '\\s*-.*')))

# create a variable that functions like all other home language variables and just says true/false for HLANO  
hhdata = hhdata %>% 
  mutate(HLANO_trueFalse = case_when(
    HLANO == "No non-official language" ~ "False",
    HLANO == "Not available" ~ NA_character_,
    !is.na(HLANO) ~ "True"
  ))
# test that this is working: 
# table(hhdata$HLANO, hhdata$HLANO_trueFalse)



```
### calculate number of languages spoken (individual)

```{r}
# count how many lanuages each person speaks:
true_false_language_columns = c("HLAEN", "HLAFR", "HLANO_trueFalse","HLBEN", "HLBFR", "HLBNO")
hhdata = hhdata  %>%
  mutate(N_languages_individual = rowSums(.[true_false_language_columns] == "True", na.rm = TRUE),
         N_languages_individual_cat = # make this a categorical variable
           case_when(Nlang_individual == 0 ~ NA_character_,
                     Nlang_individual == 1 ~ "One Language",
                     Nlang_individual > 1 ~ "Two or more",
                     TRUE ~ NA_character_))

# check result:
#View(hhdata %>% select(HH_ID, PP_ID, HLAEN:HLBNO, HLANO_trueFalse, N_languages_individual))


```

# create language pairs variable:

```{r}
# we need a column that says what languages that person speaks. So English_French, English&Italian&Other etc. 
# if a person speaks a language at home (value is "True"), then copy the column name to new column lang_pair_ordered

hhdata$lang_pair_ordered <- apply(hhdata[true_false_language_columns], 1, function(x) paste(names(x[x=="True"]), collapse="&"))


# this takes a long time to run 
# now we need to clean up the messy column names in each row:
hhdata = hhdata %>%
  mutate( lang_pair_ordered = str_remove(lang_pair_ordered, "(NA&)+|(&NA)+"), # remove NA in beginning and middle
   lang_pair_ordered =str_remove(lang_pair_ordered,"&NA"), # remove NAs at End
   lang_pair_ordered = str_replace(lang_pair_ordered, "(HLAEN)+|(HLBEN)+", "English"), # substite English column names with word english
   lang_pair_ordered = str_replace(lang_pair_ordered, "(HLAFR)+|(HLBFR)+", "French"), # same for french
   lang_pair_ordered = str_replace(lang_pair_ordered, "HLANO_trueFalse", as.character(HLANO)),
   lang_pair_ordered = str_replace(lang_pair_ordered, "HLBNO", "Other") # for HLBNO we don't know language, just call it other
   )

# check result:
#View(hhdata %>% select(HH_ID, PP_ID, HLAEN:HLBNO, HLANO_trueFalse, N_languages_individual, lang_pair_ordered))


# this takes a while to run! there are probably more efficient versions of this.. 
hdata_short = hdata_short %>%
  # calculate number of columns that are not NA out of the 6 language variables
mutate(Nlang_individual = rowSums(!is.na(data.frame(HLA_En, HLA_Fr, HLA_Oth, HLB_En, HLB_Fr, HLB_Oth))),
       # paste together information about the language pairs observed
  LangPair_individual = apply(data.frame(HLA_En, HLB_En, HLA_Fr, HLB_Fr, HLA_Oth, HLB_Oth), 1, function(x) paste(x[!is.na(x)], collapse = "_"))) %>%
  mutate(LangGroup_individual = 
           case_when(Nlang_individual == 0 ~ NA_character_,
                     Nlang_individual == 1 ~ "One Language",
                     Nlang_individual > 1 ~ "Two or more",
                     TRUE ~ NA_character_))

# minor cleaning steps for simplifying plotting
# subsume all trilinguals who speak English and French + X as English-French bilinguals
hdata_short$LangPair_isimplified = ifelse(substr(hdata_short$LangPair_individual,1,14 )=="English_French", "English_French", hdata_short$LangPair_individual)

# simplify bilinguals who speak two "other" languages - for ease of plotting
hdata_short$LangPair_isimplified  = gsub("other_other", "other", hdata_short$LangPair_isimplified)


```



## restrict to Households with kids under 10
```{r}
# restrict to kids under 10
# keep only households that have at least one child under 10
hhdata_child = hhdata %>%
  filter(number_of_children0_9 >0)
```


## summary tables: children under 9 years
```{r}


# number of bilinguals
#canadian average:
hdata_child %>%
filter(AGEGRP=="0 to 9 years") %>%
  group_by(LangGroup_individual) %>%
  summarize(N=n()) %>%
    mutate( Percent = N/sum(N)) 





(gma_LangGroup_data = hdata_child %>%
filter(AGEGRP=="0 to 9 years") %>%
  group_by(PR,CMA,LangGroup_individual) %>%
  summarize(N=n()) %>%
    mutate( Percent = round(N/sum(N),3))%>%
    filter(LangGroup_individual != "One Language"))


# specific language combos
hdata_child_langPair = hdata_child %>% 
  filter(AGEGRP=="0 to 9 years",Nlang_individual>1 ) %>%
  group_by(PR,LangPair_isimplified) %>%
  summarize(N=n())%>%
  mutate( Percent = round(N/sum(N),3))%>%
  arrange(PR, -N)

hdata_child_langPair=hdata_child_langPair %>% group_by(PR) %>%
  slice(1:5) %>%
  mutate(id=seq_along(Percent))

# add nicer language labels to graph
dict = read_csv(file= here("01_datasets","LangPair_Dict.csv"))
hdata_child_langPair = full_join(hdata_child_langPair, dict)


```


