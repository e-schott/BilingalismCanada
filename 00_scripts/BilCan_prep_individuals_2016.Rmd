---
title: "Census Bilingualism Analysis"
output:
  html_document:
    df_print: paged
---
author: Esther Schott
please email esther.schott@mail.concordia.ca if you have any questions
see poster created from this script: https://osf.io/4gekn/

# 1. Preparation Steps
## Script settings
```{r}
load_data_from_raw = FALSE # If true, loads data from .sav, else loads R file (faster)

use_reduced_data_set = FALSE # If true, uses a smaller subset of full data set (for troubleshooting etc.)
```

## load packages
```{r echo=FALSE}
library(here)
library(tidyverse)
library(rio) # for more powerful import & export of data
library(labelled)
library(janitor) # cleaning up variable names
library(codebook) # better documentation

```




# INDIVIDUALS dataset

###  read in invididuals file
if this is the first time you use this script on a computer, download the dataset from the odesi database. https://lib-ezproxy.concordia.ca/login?url=https://odesi.ca/ 
Search 2016 Census on odesi, click on the save icon and then download the .sav FILE. Might work better on chrome than firefox. (look out for the "if the download does not start, click here" link that might appear.)
```{r}


# 2016 data files
# need to update to most recent
if(load_data_from_raw == TRUE) {
raw_idata = import(here("01_datasets/pumf-98M0001-E-2016-individuals_F1.sav"), 
                      format = "sav", user_na = c("Not available", "88888888", "99999999"))
saveRDS(raw_idata, here("03_output/00_processed_data/idata_raw.Rdata"))} else {
raw_idata =   readRDS(here("03_output/00_processed_data/idata_raw.Rdata"))
}

```

### clean up column names

```{r}

dict_idata = tibble(old_name = names(raw_idata), explanation = var_label(raw_idata))
#export(dict_idata, file = here("01_datasets/ColNamesDict_idata.csv"))
individ_column_names = import(here("01_datasets/ColNamesDict_idata.csv"))


# we only want to rename columns that we created a new name for
individ_column_names_keep = individ_column_names %>%
  filter(new_name!="")
# rename columns to new name
# pull() is necessary to convert column to vector (which rename_at expects)
raw_idata = raw_idata %>% rename_at(vars(pull(individ_column_names_keep,old_name)), ~ pull(individ_column_names_keep,new_name))



```
### convert to categorical variables to factors to see variable labels
```{r}
# make factor - the spss variable has all variables stored as numeric, which makes them read into R as numeric (which means it doesn't show labels present in the dataset). Can use factorize to remedy that 

# from the column dictionary, keep only columns that are categorical 
columns_to_convert_to_factor = individ_column_names %>%
  filter(type == "categorical") %>%
  mutate(current_name = if_else(new_name== "", old_name, new_name)) %>% # some of these columns have been renamed, use new name if it was renamed
  pull(current_name)


# batch convert to factor
# this takes a bit long
raw_idata = raw_idata %>%
  mutate_at(.vars = vars(columns_to_convert_to_factor),
             .funs = factorize)
# now, instead of numbers e.g. for provice we see the actual label in the df
```



### select variables of interest
```{r}
# select which variables are necessary for our analysis
# keep all that we have renamed (to include more, edit the ColNamesDict.csv in datasets folder)

idata = raw_idata %>% select(sort(pull(individ_column_names_keep, new_name)))
```




## clean up age variables
```{r}


# create age_bracket variable... 
idata$age_bracket = ifelse(as.integer(idata$age_group)>6, "adult","child") # the 6th level is "15 to 17 years"

table( idata$age_group, idata$age_bracket)

```


## use subset of full data (for troubleshooting)
```{r}
if(use_reduced_data_set == TRUE) {
  idata = idata %>%
    sample_n(50000)
}
```
# cleanup language variables

### simplify language factor levels
```{r}

idata = idata %>%
  mutate_at( .vars = vars(lang_most_eng, lang_most_fre, lang_regular_eng, lang_regular_fre, lang_regular_oth),
             ~ fct_relabel(., ~str_remove(., '\\s*-.*')))
```



### clean up Write-in component for non-official languages
```{r}
idata = idata %>%
  
  mutate(lang_most_oth_write_in = case_when(
    lang_most_oth_write_in == "No non-official language" ~ "",
    lang_most_oth_write_in == "Not available" ~ NA_character_,
    lang_most_oth_write_in == "All other languages" ~ "Other",
    str_detect(lang_most_oth_write_in, "languages")  ~ sub(" languages", "", lang_most_oth_write_in),

    TRUE ~  sub(" \\(.*", "", lang_most_oth_write_in)
  ))

# create a variable that functions like all other home language variables and just says true/false for lang_most_oth_write_in  
idata = idata %>% 
  mutate(lang_most_oth = case_when(
    lang_most_oth_write_in == "" ~ "False",
    lang_most_oth_write_in == "No non-official language" ~ "False",
    lang_most_oth_write_in == "Not available" ~ NA_character_,
    !is.na(lang_most_oth_write_in) ~ "True"
  ))
```



### calculate number of languages spoken (individual)

```{r}
# count how many lanuages each person speaks:
true_false_language_columns = c("lang_most_eng", "lang_most_fre", "lang_most_oth","lang_regular_eng", "lang_regular_fre", "lang_regular_oth")

idata = idata  %>% 
  mutate(n_languages_numeric = rowSums(.[true_false_language_columns] == "True", na.rm = TRUE)    ,
         n_languages = # make this a categorical variable
           case_when(n_languages_numeric == 0 ~ NA_character_,
                     n_languages_numeric == 1 ~ "One Language",
                     n_languages_numeric > 1 ~ "Two or more",
                     TRUE ~ NA_character_))

# check result:
#View(idata %>% select( person_id, lang_most_eng:lang_regular_oth, lang_most_oth, n_languages))


```

### create language pairs variable

```{r}
# we need a column that says what languages that person speaks. So English_French, English&Italian&Other etc. 
# if a person speaks a language at home (value is "True"), then copy the column name to new column lang_pair_ordered

# sorted by most spoken then regularly spoken languages (for the person)
idata$lang_pair_ordered <- apply(idata[true_false_language_columns], 1, function(x) paste(names(x[x=="True"]), collapse="&"))



# this takes a long time to run 
# now we need to clean up the messy column names in each row:
idata = idata %>%
  mutate( lang_pair_ordered = str_remove(lang_pair_ordered, "(NA&)+|(&NA)+"), # remove NA in beginning and middle
   lang_pair_ordered =str_remove(lang_pair_ordered,"&NA"), # remove NAs at End
   lang_pair_ordered = str_replace(lang_pair_ordered, "(lang_most_eng)+|(lang_regular_eng)+", "English"), # substite English column names with word english
   lang_pair_ordered = str_replace(lang_pair_ordered, "(lang_most_fre)+|(lang_regular_fre)+", "French"), # same for french
   lang_pair_ordered = str_replace(lang_pair_ordered, "lang_most_oth", as.character(lang_most_oth_write_in)),
   lang_pair_ordered = str_replace(lang_pair_ordered, "lang_regular_oth", "Other") # for lang_regular_oth we don't know language, just call it other
   )

# check result:
#View(idata %>% select(person_id, lang_most_eng:lang_regular_oth, lang_most_oth, n_languages, lang_pair_ordered))




```
### create variables for each language in dataset
```{r}

idata  =  idata %>%
  separate(lang_pair_ordered, c("lang1", "lang2", "lang3", "lang4"), remove = FALSE)
# warning that not all people have 4 languages is normal
```



### simplify language pairs variable (sorted A-Z)
```{r}

# remove order by most spoken then regularly spoken languages (now sorted by A-Z)
idata$lang_pair <- apply(idata[c("lang1", "lang2", "lang3","lang4")], 1, function(x) paste(sort(x[!is.na(x)]), collapse="&"))

```
## get columns back in alphabetical order
```{r}
idata = idata %>% select(sort(names(idata)))
```





### create variable for geographical locations of interest
```{r}

idata$area = fct_recode(idata$area, Other = "Other census metropolitan areas, census agglomerations and o", `Greater Sudbury - Thunder Bay` = "Greater Sudbury / Grand Sudbury – Thunder Bay")

idata$area_interest = ifelse(idata$area %in% c("Vancouver", "Montréal", "Toronto","Ottawa - Gatineau" , "Calgary", "Edmonton"),as.character(idata$area), NA)
```


 

## keep only children 0-4, save idata_child for creating map
is this still used?? need to check 
previously this only saved data from 0-4, may need changes in  other scripts

```{r}

idata_child = idata %>%
  filter(age_group %in% c("0 to 4 years", "5 to 6 years", "7 to 9 years"))
saveRDS(idata_child, file = here::here("03_output","00_processed_data", "Individuals_child_data.rdata"))

  
#gma_LangGroup_data = gma_LangGroup_data %>% 
#  mutate(Area = agrep()

```




#  Individuals dataset: descriptives
### summary tables: children across canada
check how distributions over province and metropolitain areas are
```{r}
# select only adults who are living with at least one child
idata_hh_child = idata %>% 
  filter(n_child_0_to_1 =="One or more" | n_child_2_to_5 =="One or more") %>% 
  filter(age_bracket=="adult")

# how many are there per province & area?
idata_hh_child %>% group_by(province, area) %>%
  summarize(N=n()) %>% 
  spread(province, N)

# breakdown by province
idata_child %>% group_by(province) %>%
  summarize(N=n())

# some provinces have  few data points. can probably concentrate on BC, Alberta, Ontario, Quebec



# top metropolitain areas
idata_child %>% group_by(area) %>%
   summarize(N=n()) %>%
  arrange(-N)
# top metropolitain areas are: Toronto, Montréal, Vancouver Calgary, Ottawa - Gatineau, Edmonton (cutoff could be 5000 individuals?)

```
## bilingualism in children in individuals dataset
#### summary table: bilingual children across canada

```{r}
 idata %>% filter(age_bracket == "child") %>%
   group_by(age_group, n_languages) %>%
   summarize(N=n()) %>%
   spread(n_languages, N) %>%
   clean_names() %>%
   mutate(total = one_language+two_or_more, percent = two_or_more/total)


```

#### summary tables: bilingual children under 6yo by province & metropolitan area
```{r}
# commented out because I need to fix langGroup

# idata %>% filter(AGEGRP == "0 to 4 years"| AGEGRP =="5 to 6 years") %>%
#   group_by(gma.interest, LangGroup_individual) %>%
#   summarize(N=n()) %>%
#   spread(LangGroup_individual, N) %>%
#   clean_names() %>%
#   mutate(total = one_language+two_or_more, percent = round(two_or_more/total,3)) 

```


#### summary tables: number of bilingual adults living with a child under 5

```{r}
# commented out because I need to fix langGroup

# 
# idata_child %>%
#   filter(Child0_1 == "1+"  ) %>%
#   group_by(LangGroup_individual) %>%
#   summarize(Count = n())%>%
#   mutate(           Percent = Count/sum(Count))
# 
# # broken down by key metropolotain areas
# 
# idata_child %>%
#   filter(!is.na(gma.interest)& Child0_1 == "1+" |Child2_5=="1+") %>%
#   group_by( gma.interest, LangGroup_individual) %>%
#   summarize(Count = n())%>%
#   mutate(           Percent = Count/sum(Count)) 
#   
# 
# 
# # need to investigate what to do with these NA in other language
# idata_child %>% filter(is.na(LangGroup)) %>% 
#   group_by(LangPair_simplified) %>% 
#   summarize(count=n())
# 
# # look at 2-5 year olds
# idata_child %>% 
#   filter(Child2_5 == "1+") %>%
#   group_by(LangGroupBil) %>%
#   summarize(Count = n())  %>%
#   mutate(           Percent = Count/sum(Count))

# these look relatively the same as the one-year olds, focus on the one-year olds becuase they are our population of interest and 2-5 year olds likely get more exposure outside of the house (not captured in this survey)
```

# save data for future analysis
```{r}
export(idata, file = here::here("03_output","00_processed_data", "idata_preprocessed.Rdata")) 
beepr::beep("ping")
```

