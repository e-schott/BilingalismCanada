---
title: "Census Bilingualism Analysis"
output:
  html_document:
    df_print: paged
---
author: Esther Schott
please email esther.schott@mail.concordia.ca if you have any questions
see poster created from this script: https://osf.io/4gekn/

# 1. Preparation Steps
## Script settings
```{r}
load_data_from_raw = FALSE # If true, loads data from .sav, else loads R file (faster)

use_reduced_data_set = FALSE # If true, uses a smaller subset of full data set (for troubleshooting etc.)
```

## load packages
```{r echo=FALSE}
library(here)
library(tidyverse)
library(rio) # for more powerful import & export of data
library(labelled)
library(janitor) # cleaning up variable names
library(codebook) # better documentation
library(snakecase)

```




# INDIVIDUALS dataset

###  read in invididuals file
if this is the first time you use this script on a computer, download the dataset from the odesi database. https://lib-ezproxy.concordia.ca/login?url=https://odesi.ca/ 
Search 2016 Census on odesi, click on the save icon and then download the .sav FILE. Might work better on chrome than firefox. (look out for the "if the download does not start, click here" link that might appear.)
```{r}


# 2016 data files
if(load_data_from_raw == TRUE) {
raw_idata = import(here("01_datasets/pumf-98M0001-E-2016-individuals_F1.sav"), 
                      format = "sav", user_na = c("Not available", "88888888", "99999999"))
saveRDS(raw_idata, here("03_output/00_processed_data/idata_raw.Rdata"))} else {
raw_idata =   readRDS(here("03_output/00_processed_data/idata_raw.Rdata"))
}

```

### clean up column names

```{r}

dict_idata = tibble(old_name = names(raw_idata), explanation = var_label(raw_idata))
#export(dict_idata, file = here("01_datasets/ColNamesDict_idata.csv"))
individ_column_names = import(here("01_datasets/ColNamesDict_idata.csv"))


# we only want to rename columns that we created a new name for
individ_column_names_keep = individ_column_names %>%
  filter(new_name!="")
# rename columns to new name
# pull() is necessary to convert column to vector (which rename_at expects)
raw_idata = raw_idata %>% rename_at(vars(pull(individ_column_names_keep,old_name)), ~ pull(individ_column_names_keep,new_name))



```
### convert to categorical variables to factors to see variable labels
```{r}
# make factor - the spss variable has all variables stored as numeric, which makes them read into R as numeric (which means it doesn't show labels present in the dataset). Can use factorize to remedy that 

# from the column dictionary, keep only columns that are categorical 
columns_to_convert_to_factor = individ_column_names %>%
  filter(type == "categorical") %>%
  mutate(current_name = if_else(new_name== "", old_name, new_name)) %>% # some of these columns have been renamed, use new name if it was renamed
  pull(current_name)


# batch convert to factor
# this takes a bit long
raw_idata = raw_idata %>%
  mutate_at(.vars = vars(columns_to_convert_to_factor),
             .funs = factorize)
# now, instead of numbers e.g. for provice we see the actual label in the df
```



### select variables of interest
```{r}
# select which variables are necessary for our analysis
# keep all that we have renamed (to include more, edit the ColNamesDict.csv in datasets folder)

idata = raw_idata %>% select(sort(pull(individ_column_names_keep, new_name)))
```




## clean up age variables
```{r}


# create age_bracket variable... 
idata$age_bracket = ifelse(as.integer(idata$age_group)>6, "adult","child") # the 6th level is "15 to 17 years"

table( idata$age_group, idata$age_bracket)

```


## use subset of full data (for troubleshooting)
```{r}
if(use_reduced_data_set == TRUE) {
  idata = idata %>%
    sample_n(50000)
}
```
# cleanup language variables

### simplify language factor levels
```{r}
# remove the long label names and just keep the true/false label, for easier use later
idata = idata %>%
  mutate_at( .vars = vars(lang_most_eng, lang_most_fre, lang_regular_eng, lang_regular_fre, lang_regular_oth),
             ~ fct_relabel(., ~str_remove(., '\\s*-.*')))


```



### clean up Write-in component for non-official languages (language heard most)
```{r}
idata = idata %>%
  
  mutate(lang_most_oth_name = case_when(
    lang_most_oth_write_in == "No non-official language" ~ "",
    lang_most_oth_write_in == "Not available" ~ NA_character_,
    lang_most_oth_write_in == "All other languages" ~ "Other",
    str_detect(lang_most_oth_write_in, "languages")  ~ sub(" languages", "", lang_most_oth_write_in),
     
    TRUE ~  sub(" \\(.*", "", lang_most_oth_write_in)
  ),
  lang_most_oth_name = str_remove(lang_most_oth_name, "Persian|Panjabi|PilipinoFilipino")

  )

# clean up naming convention to camel case to make it easier to paste and combine later (spaces are removed)
idata$lang_most_oth_name = to_any_case(as.character(idata$lang_most_oth_name), case = "big_camel")


# create a variable that functions like all other home language variables and just says true/false for lang_most_oth_write_in  
idata = idata %>% 
  mutate(lang_most_oth = case_when(
    lang_most_oth_name == "" ~ "False",
    lang_most_oth_name == "Not available" ~ NA_character_,
    is.na(lang_most_oth_name) ~ NA_character_,
    !is.na(lang_most_oth_write_in) ~ "True"
  ))
```

### clean up Write-in component for non-official languages (language heard regularly)
```{r}
idata = idata %>%
  
  mutate(lang_most_oth_name = case_when(
    lang_most_oth_write_in == "No non-official language" ~ "",
    lang_most_oth_write_in == "Not available" ~ NA_character_,
    lang_most_oth_write_in == "All other languages" ~ "Other",
    str_detect(lang_most_oth_write_in, "languages")  ~ sub(" languages", "", lang_most_oth_write_in),
     
    TRUE ~  sub(" \\(.*", "", lang_most_oth_write_in)
  ),
  lang_most_oth_name = str_remove(lang_most_oth_name, "Persian|Panjabi|PilipinoFilipino")

  )

# clean up naming convention to camel case to make it easier to paste and combine later (spaces are removed)
idata$lang_most_oth_name = to_any_case(as.character(idata$lang_most_oth_name), case = "big_camel")


# create a variable that functions like all other home language variables and just says true/false for lang_most_oth_write_in  
idata = idata %>% 
  mutate(lang_most_oth = case_when(
    lang_most_oth_name == "" ~ "False",
    lang_most_oth_name == "Not available" ~ NA_character_,
    is.na(lang_most_oth_name) ~ NA_character_,
    !is.na(lang_most_oth_write_in) ~ "True"
  ))
```

### calculate number of languages spoken (individual)
```{r}
# count how many lanuages each person speaks:
true_false_language_columns = c("lang_most_eng", "lang_most_fre", "lang_most_oth","lang_regular_eng", "lang_regular_fre", "lang_regular_oth")

idata = idata  %>% 
  mutate(n_languages_numeric = rowSums(.[true_false_language_columns] == "True", na.rm = TRUE)    ,
         n_languages = # make this a categorical variable
           case_when(n_languages_numeric == 0 ~ NA_character_,
                     n_languages_numeric == 1 ~ "One Language",
                     n_languages_numeric > 1 ~ "Two or more",
                     TRUE ~ NA_character_))

# check result:
#View(idata %>% select( person_id, lang_most_eng:lang_regular_oth, lang_most_oth, n_languages))


# count how many lanuages each person speaks:
true_false_language_used_most = c("lang_most_eng", "lang_most_fre", "lang_most_oth")
true_false_language_used_regularly = c("lang_regular_eng", "lang_regular_fre", "lang_regular_oth")

idata = idata  %>% 
  mutate(n_languages_used_most = rowSums(.[true_false_language_used_most] == "True", na.rm = TRUE),
         n_languages_used_regularly = rowSums(.[true_false_language_used_regularly] == "True", na.rm = TRUE))
         



```

### create language pairs variable
xxx need to figure out what to do with people who report no language as "used most"
```{r}
# we need a column that says what languages that person speaks. So English_French, English&Italian&Other etc. 
# if a person speaks a language at home (value is "True"), then copy the column name to new column lang_pair_ordered

# sorted by most spoken then regularly spoken languages (for the person)
idata$lang_pair_most <- apply(idata[true_false_language_used_most], 1, function(x) paste(names(x[x=="True"]), collapse="&"))
idata$lang_pair_regular <- apply(idata[true_false_language_used_regularly], 1, function(x) paste(names(x[x=="True"]), collapse="&"))



```

### clean up language pair variables
```{r}
# need to create a function here!
# this takes a long time to run 
# now we need to clean up the messy column names in each row:
idata = idata %>%
  mutate( lang_pair_most = ifelse(n_languages_numeric <2, NA_character_, lang_pair_most),
    lang_pair_most = str_remove(lang_pair_most, "(NA&)+|(&NA)+"), # remove NA in beginning and middle
   lang_pair_most =str_remove(lang_pair_most,"(&NA)+|(NA)+"), # remove NAs at End
   lang_pair_most = str_replace(lang_pair_most, "lang_most_eng", "English"), # substitute English column names with word english
   lang_pair_most = str_replace(lang_pair_most, "lang_most_fre", "French"), # same for french
   lang_pair_most = str_replace(lang_pair_most, "lang_most_oth", as.character(lang_most_oth_name)),
  )

# for langauges heard regularly
idata = idata %>%
  mutate( lang_pair_regular = ifelse(n_languages_numeric <2, NA_character_, lang_pair_regular),
          lang_pair_regular = str_remove(lang_pair_regular, "(NA&)+|(&NA)+"), # remove NA in beginning and middle
   lang_pair_regular =str_remove(lang_pair_regular,"&NA"), # remove NAs at End
   lang_pair_regular = str_replace(lang_pair_regular, "lang_regular_eng", "English"), # substitute English column names with word english
   lang_pair_regular = str_replace(lang_pair_regular, "lang_regular_fre", "French"), # same for french
   lang_pair_regular = str_replace(lang_pair_regular, "lang_regular_oth", "Other") # for lang_regular_oth we don't know language, just call it other
   )

```
# combined languages used most and languages used regularly
for now, we don't distinguish between those two!
```{r}

idata$lang_pair =  as.vector(apply(cbind(idata$lang_pair_most, idata$lang_pair_regular), 1, 
             function(x) paste(x[!is.na(x)& !x==""], collapse = "&")))
  idata %>% count(lang_pair) %>% arrange(-n) %>% View()
```

# sort languages from a-z
needed to create language pair variable that does not distinguish between "English & French" and "French & English"
```{r}

# get the individual language names so we can combine them into pairs
idata = idata %>%
  separate(col = lang_pair, into = c("lang1", "lang2", "lang3", "lang4"), sep = "&")

# remove order by most spoken then regularly spoken languages (now sorted by A-Z)
# this takes long to run
idata$lang_pair <- apply(idata[c("lang1", "lang2", "lang3","lang4")], 1, function(x) paste(sort(x[!is.na(x)]), collapse="&"))

# get the sorted languages back
# get the individual language names so we can combine them into pairs
idata = idata %>%
  separate(col = lang_pair, into = c("lang1", "lang2", "lang3", "lang4"), sep = "&", remove = F)

```



# create a long data frame with all language pairings per person
The goal of this is to show which languages are often combined with each other. For example, how many ppl are in Montreal speaking Arabic and French vs in Edmonton. It's okay if these people also speak another language. Therefore, we will create an extra dataframe that has multiple rows for trilingual ppl 
```{r}

# create all possible pairings
idata = idata %>% 
  mutate(pairing_1 = ifelse(!is.na(lang1) & !is.na(lang2), 
                             paste(lang1, lang2, sep = "&"), NA_character_),
         pairing_2 =        ifelse(!is.na(lang1) & !is.na(lang3), 
                             paste(lang1, lang3, sep = "&"), NA_character_),
         pairing_3  =       ifelse(!is.na(lang2) & !is.na(lang3), 
                             paste(lang2, lang3, sep = "&"), NA_character_),
         pairing_4 =        ifelse(!is.na(lang1) & !is.na(lang4), 
                             paste(lang1, lang4, sep = "&"), NA_character_),
         pairing_5 =        ifelse(!is.na(lang2) & !is.na(lang4), 
                             paste(lang2, lang4, sep = "&"), NA_character_),
         pairing_6 =        ifelse(!is.na(lang3) & !is.na(lang4), 
                              paste(lang3, lang4, sep = "&"), NA_character_))
                            
lang_pair_data = idata %>%
  filter(n_languages_numeric>1) %>%
  gather(number, language_pair, pairing_1:pairing_6) %>%
  filter(!is.na(language_pair))
  

```

# languages in canada overall
```{r}
lang_pair_data %>% filter(age_group == "0 to 4 years") %>% group_by(age_group) %>% count(language_pair) %>% mutate(percent = round(n/sum(n)*100)) %>% arrange(-percent) %>% top_n(10) %>% View()
```

## fixing language combo names
```{r}
language_pair_dictionary = tibble(language_pair_old = unique(lang_pair_data$language_pair)) %>%
  filter(str_detect(language_pair_old, "Other|AustroAsiatic", negate = TRUE)) %>%
  mutate(language_pair = gsub("&", " & ", language_pair_old),
         fix = str_detect( language_pair, "^English|^French|^Abo", negate = TRUE)) %>% 
  separate(language_pair, into = c("lang1", "lang2"), sep = " & ", remove = FALSE) %>%
  mutate(language_pair = ifelse(fix == TRUE, paste(lang2, lang1, sep = " & "), language_pair)) %>%
  select(language_pair, language_pair_old)



```


# Table 2: look at languages by province
## prep 
```{r}
age_groups_of_interest = c("0 to 4 years", "5 to 6 years", "7 to 9 years")

# how many children are in the census dataset (regardless of languages spoken)
n_children_by_age = idata %>% filter(age_group %in% age_groups_of_interest) %>%
  mutate(age_collapsed = fct_collapse(age_group, 
                      "age_0_to_4" = "0 to 4 years",
                      "age_5_to_9" = c("5 to 6 years", "7 to 9 years"))) %>% 
  group_by(province, age_collapsed) %>% 
  count(name = "total_by_age") %>%
  ungroup()



```

## percentage out of bilingual/all children by age group
 separate for 0-4 and 5-9 yo
```{r}

lang_pair_by_province_and_age_long  = 
  lang_pair_data %>% 
  filter(age_group %in% age_groups_of_interest) %>%
  # collapse two older ages into one category
  mutate(age_collapsed = fct_collapse(age_group, 
                      "age_0_to_4" = "0 to 4 years",
                      "age_5_to_9" = c("5 to 6 years", "7 to 9 years"))) %>% 
  group_by(province, age_collapsed) %>% 
  count(language_pair) %>% 
  left_join(n_children_by_age) %>% # how how many children per age group
  mutate(n_bilingual_children = sum(n),
    percent_bilingual_children = round(n/n_bilingual_children*100,1), # add percent
    percent_all_children = round(n/total_by_age*100,1)) %>% 
  ungroup() 

lang_pair_by_province_and_age = lang_pair_by_province_and_age_long %>%
  select( - n, -total_by_age, - n_bilingual_children) %>% 
  pivot_wider(names_from = age_collapsed, values_from = c("percent_bilingual_children","percent_all_children"))

```
## percentage out of all children, combined for ages 0-9
```{r}
lang_pair_by_province_all_ages_combined = lang_pair_data %>% 
  
  # collapse two older ages into one category
  mutate(age_combined = fct_collapse(age_group, 
                            "age_0_to_9" = age_groups_of_interest)) %>%
  filter(age_combined == "age_0_to_9") %>%
  # count how many children per language pair
  group_by(province) %>%
  count(language_pair) %>% 
  # merge in number of children collapsed across ages
   full_join(n_children_by_age %>% group_by(province) %>% summarize(total_by_age = sum(total_by_age))) %>%
  #calculate percentages
  
   mutate(percent_bilingual_children_age_0_9 = round(n/sum(n)*100,1), # add percent
         percent_all_children_age_0_9 = round(n/total_by_age*100, 1)) %>% 
  select(-n, -total_by_age)
  
```



## combine detailed age breakdown and summary across all ages of interest
```{r}
# 
lang_pair_by_province = lang_pair_by_province_and_age %>% 
  full_join(lang_pair_by_province_all_ages_combined) %>%
  # remove other label
  mutate( other_flag = str_detect(language_pair, "Other")) %>%
  filter(other_flag != TRUE) %>% 
  # exclude language combos that appear very rarely
  filter(percent_bilingual_children_age_0_9 >= 4) %>% 
  select(-other_flag) %>%
  arrange(province, -percent_bilingual_children_age_0_9) %>%
    # fix language pair names
  rename(language_pair_old = language_pair) %>% 
  left_join(language_pair_dictionary, by = "language_pair_old") %>%
  select(-language_pair_old) %>%
  relocate(language_pair, 
           .after = province) %>%
  relocate(percent_bilingual_children_age_0_9, 
           .after = percent_bilingual_children_age_5_to_9)


lang_pair_by_province %>%
  write_csv(here("03_output", "02_tables", "language_pairs_by_province.csv"))




```


### create variable for geographical locations of interest
```{r}

idata$area = fct_recode(idata$area, Other = "Other census metropolitan areas, census agglomerations and o", `Greater Sudbury - Thunder Bay` = "Greater Sudbury / Grand Sudbury – Thunder Bay")

idata$area_interest = ifelse(idata$area %in% c("Vancouver", "Montréal", "Toronto","Ottawa - Gatineau" , "Calgary", "Edmonton"),as.character(idata$area), NA)
```


 

## keep only children 0-4, save idata_child for creating map
is this still used?? need to check 
previously this only saved data from 0-4, may need changes in  other scripts

```{r}

idata_child = idata %>%
  filter(age_group %in% c("0 to 4 years", "5 to 6 years", "7 to 9 years"))
saveRDS(idata_child, file = here::here("03_output","00_processed_data", "Individuals_child_data.rdata"))

  
#gma_LangGroup_data = gma_LangGroup_data %>% 
#  mutate(Area = agrep()

```




#  Individuals dataset: descriptives
### summary tables: children across canada
check how distributions over province and metropolitain areas are
```{r}
# select only adults who are living with at least one child
idata_hh_child = idata %>% 
  filter(n_child_0_to_1 =="One or more" | n_child_2_to_5 =="One or more") %>% 
  filter(age_bracket=="adult")

# how many are there per province & area?
idata_hh_child %>% group_by(province, area) %>%
  summarize(N=n()) %>% 
  spread(province, N)

# breakdown by province
idata_child %>% group_by(province) %>%
  summarize(N=n())

# some provinces have  few data points. can probably concentrate on BC, Alberta, Ontario, Quebec



# top metropolitain areas
idata_child %>% group_by(area) %>%
   summarize(N=n()) %>%
  arrange(-N)
# top metropolitain areas are: Toronto, Montréal, Vancouver Calgary, Ottawa - Gatineau, Edmonton (cutoff could be 5000 individuals?)

```
## bilingualism in children in individuals dataset
#### summary table: bilingual children across canada

```{r}
 idata %>% filter(age_bracket == "child") %>%
   group_by(age_group, n_languages) %>%
   summarize(N=n()) %>%
   spread(n_languages, N) %>%
   clean_names() %>%
   mutate(total = one_language+two_or_more, percent = two_or_more/total)


```





# save data for future analysis
```{r}
export(idata, file = here::here("03_output","00_processed_data", "idata_preprocessed.Rdata")) 
beepr::beep("ping")
```

